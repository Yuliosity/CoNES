ct U[25] game_palette = U[25](
    // Tiles
    $0a, $12, $22,
    $00, $16, $27,
    $1c, $18, $29,
    $00, $10, $15,
    // Sprites
    $0c, $00, $00,
    $0f, $0f, $0f,
    $0f, $0f, $0f,
    $0f, $0f, $0f,
    // Background color
    $0f)

ct U LEFT_BORDER = 24
ct U TOP_BORDER = 24
vars /level
    U[216] map

vars /player
    U player_x = 2
    U player_y = 2
    U player_z = 2
    //U player_hp = 10

//Gethe the NW tile of a cell.         
//They are organized in 2x2 metatiles, so the rest are:
//      x NW NE x + 1
//x + $10 SW SE x + $11
fn get_tile(U cell) U
    ct U[10] res = U[10]($00, $68, $6A, $8E, $60, $62, $66, $64, $6C, $6E)
    U tile = $FF
    //TODO: hidden cells
    cell &= $7F
    if cell < 10
        tile = res[cell]
    else if cell == $24 //Coin
        tile = $86
    else if cell == $28 //Flare
        tile = $84
    else if cell & $40 //Monster
        tile = $A0 | (((cell >> 3) & $07) << 1)
    return tile

fn generate_map()
    //76543210 - 8-bit format of the ConE map cell
    //7 - visited (known) cell
    //6 - is a monster
    //if 6 set, 543 are monster's lower index; 210 are monster's current HP
    //monster's upper index is current_floor mod 2, so full undex is 8*upper+lower
    //if 6 not set:
    //  5 - is a collectable item;
    //  if 5 set, 4 - is an artefact
    //  if 5 set and 4 set,     321 are: 0-4 gems, 5 goldsign, 6 bluefire; bit 0 is unused
    //  if 5 set and 4 not set, 32 are: 0 gold, 1 flare, 2 lamp, 3 unused; 10 are unused
    //  if 5 not set, it's an interactive object, and 4 is a final boss with 3210 extra HPs
    //  if 5 not set and 4 not set, 3210 are:
    //    0 empty cell, 1 chest,       2 book, 3 vendor
    //    4 stairs up,  5 stairs down, 6 warp, 7 sinkhole
    //    8 orb,        9 pool, 10-14 unused (different vendors?)
    //    15 - empty cell
    for U i = 0; i < 216; i += 1
        U x = rand()
        U y
        if x < $50
            y = $40 | (x & 8 << 3) | (x & 8) //Monster type x mod 8, with type-dependent HP
        else if x < $60
            y = $01 //Chest
        else if x < $70
            y = $02 //Book
        else if x < $80
            y = $24 //Coin
        else if x < $90
            y = $28 //Flare
        else if x < $98
            y = $03 //Vendor
        else if x < $A0
            y = $06 //Warp
        else if x < $A8
            y = $07 //Sinkhole
        else if x < $B0
            y = $08 //Orb
        else if x < $B8
            y = $09 //Pool
        else
            y = $00 //Empty
        map[i] = y

        // TODO: also place:
        // artefacts
        // final boss
        // stairs
        // lamp

fn render_floor()
    U offset = U(player_z * 36)
    UU row_addr = $2063
    //Iterate by rows
    for U i = 0; i < 6; i += 1
        UU addr = row_addr
        for U j = 0; j < 6; j += 1
            U tile_id = get_tile(map[offset + j])
            if tile_id == 0 //Empty tile
                //Draw the top half
                ppu_reset_addr(addr)
                {PPUDATA}(0)
                {PPUDATA}(0)
                //Draw the bottom half
                ppu_reset_addr(addr + $20)
                {PPUDATA}(0)
                {PPUDATA}(0)
            else
                //Draw the top half
                ppu_reset_addr(addr)
            {PPUDATA}(tile_id)
            {PPUDATA}(tile_id + 1)
        //Draw the bottom half
                ppu_reset_addr(addr + $20)
            {PPUDATA}(tile_id + $10)
            {PPUDATA}(tile_id + $11)
            //TODO: set attributes
            addr += 3
        offset += 6
        row_addr += $60

    // for UU i = 0; i < 1024; i += 1
    //     {PPUDATA}(U(i))
    ppu_reset_addr($23C0)
    for U i = 0; i < 64; i += 1
        {PPUDATA}(%01101001)

fn inc_wrap(U val) U
    val += 1
    if val > 5
        val = 0
    return val

fn dec_wrap(U val) U
    if val == 0
        val = 6
    return val - 1

fn set_player_x()
    U scr_x = TOP_BORDER + U(player_x * 24)
    set_oam_x(0, scr_x)
    set_oam_x(4, scr_x + 8)
    set_oam_x(8, scr_x)
    set_oam_x(12, scr_x + 8)

fn set_player_y()
    U scr_y = LEFT_BORDER + U(player_y * 24)
    set_oam_y(0, scr_y)
    set_oam_y(4, scr_y)
    set_oam_y(8, scr_y + 8)
    set_oam_y(12, scr_y + 8)

fn pads_level()
    U pressed = pads[0].pressed
    if pressed & BUTTON_UP
        player_y = dec_wrap(player_y)
        set_player_y()
    else if pressed & BUTTON_DOWN
        player_y = inc_wrap(player_y)
        set_player_y()
    if pressed & BUTTON_LEFT
        player_x = dec_wrap(player_x)
        set_player_x()
    else if pressed & BUTTON_RIGHT
        player_x = inc_wrap(player_x)
        set_player_x()

nmi main_nmi()
    ppu_upload_oam_poll_pads(0)

    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)


fn set_oam_pa(I.oam index, U p, U a)
: +inline
    oam{OAM_P + UU(index)} = p
    oam{OAM_A + UU(index)} = a

mode main() 
: nmi main_nmi
    // Set the palette:
    palette = game_palette
    ppu_upload_palette()

    generate_map()
    player_x = 2 //randb(6)
    player_y = 2 //randb(6)
    player_z = 2 //randb(6)
    render_floor()

    //Set the player sprite
    set_oam_pa(0, $E2, 0)
    set_oam_pa(4, $E3, 0)
    set_oam_pa(8, $F2, 0)
    set_oam_pa(12, $F3, 0)
    set_player_x()
    set_player_y()

    //Set sprites for room borders
    U spr = 16
    for U x = 16; x < 16 + 7 * 24; x += 24
        for U y = 16; y < 16 + 7 * 24; y += 24
            spr = push_oam(spr, x, y, $FB, 0)
    hide_oam(spr)

    ppu_reset_scroll(0, 0)
    {PPUCTRL}(PPUCTRL_NMI_ON)

    while true
        update_pads()
        pads_level()
        nmi

chrrom
    file(fmt, "assets/tileset.chr")
