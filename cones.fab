ct U[25] game_palette = U[25](
    // Tiles
    $0a, $12, $22,
    $00, $16, $27,
    $1c, $18, $29,
    $00, $10, $15,
    // Sprites
    $0a, $12, $22,
    $00, $16, $27,
    $1c, $18, $29,
    $00, $10, $15,
    // Background color
    $0f)

ct U LEFT_TILE = 3
ct U TOP_TILE = 3
ct U LEFT_SCREEN = U(8 * LEFT_TILE)
ct U TOP_SCREEN = U(8 * TOP_TILE)

data /bkg
    [] level_bkg
        file(raw, "assets/layout.nam")

fn load_nametable(CCC/bkg nametable)
    ppu_reset_addr($2000)
    for UU i = 0; i < 1024; i += 1
        {PPUDATA}(nametable{i})

ct U ACT_NOTHING = 0
ct U ACT_DRAW_CELL = 1
ct U ACT_DRAW_FLOOR = 2

vars /level
    U[216] map
    Bool visible_debug = false
    U action = 0
    U to_redraw = 0

vars /player
    U player_x = 2
    U player_y = 2
    U player_z = 2
    //U player_hp = 10

fn generate_map()
    for U i = 0; i < 216; i += 1
        U x = rand()
        U y
        if x < $50
            y = $40 | (x & 8 << 3) | (x & 8) //Monster type x mod 8, with type-dependent HP
        else if x < $60
            y = CHEST
        else if x < $70
            y = BOOK
        else if x < $80
            y = COIN
        else if x < $90
            y = FLARE
        else if x < $98
            y = VENDOR
        else if x < $A0
            y = WARP
        else if x < $A8
            y = SINKHOLE
        else if x < $B0
            y = ORB
        else if x < $B8
            y = POOL
        else
            y = $00 //Empty
        map[i] = y

        // TODO: also place:
        // artefacts
        // final boss
        // stairs
        // lamp

//OAM addresses for cells of a floor
ct fn cell_addr() UU[36]
    UU[36] res
    for U y = 0; y < 6; y += 1
        for U x = 0; x < 6; x += 1
            res[U(y * 6) + x] = $2000 + UU($20 * (TOP_TILE + U(3 * y))) + UU(LEFT_TILE + U(3 * x))
    return res

fn render_cell(UU addr, U tile)
: +inline
    if tile == 0
        //Draw the top half
        ppu_set_addr(addr)
        {PPUDATA}(0)
        {PPUDATA}(0)
        //Draw the bottom half
        ppu_set_addr(addr + $20)
        {PPUDATA}(0)
        {PPUDATA}(0)
    else
        //Draw the top half
        ppu_set_addr(addr)
        {PPUDATA}(tile)
        {PPUDATA}(tile + 1)
        //Draw the bottom half
        ppu_reset_addr(addr + $20)
        {PPUDATA}(tile + $10)
        {PPUDATA}(tile + $11)
    ppu_reset_scroll(0, 0) //HACK
    //TODO: set attributes

fn show_current_cell()
    U i = U(player_y * 6) + player_x
    UU addr = cell_addr()[i]
    i += U(player_z * 36)
    map[i] |= $80
    render_cell(addr, cell_tile()[map[i] & $7F])

fn render_floor()
    I.map cell = I.map(floor_offset()[player_z])
    UU row_addr = cell_addr()[0]
    if visible_debug
        for U i = 0; i < 6; i += 1
            to_redraw -= 1
            render_cell(cell_addr()[to_redraw], cell_tile()[cell[to_redraw] & $7F])
    else
        for U i = 0; i < 6; i += 1
            to_redraw -= 1
            if (cell[to_redraw] & $80)
                render_cell(cell_addr()[to_redraw], cell_tile()[cell[to_redraw] & $7F])
            else //Hidden cell
                render_cell(cell_addr()[to_redraw], $2E)
    if !to_redraw
        action = ACT_NOTHING
    //TODO: set attributes

fn redraw()
: +inline
    {PPUSTATUS}()
    if action == ACT_DRAW_CELL
        show_current_cell()
    else if action == ACT_DRAW_FLOOR
        render_floor()

fn inc_wrap(U val) U
    val += 1
    if val > 5
        val = 0
    return val

fn dec_wrap(U val) U
    if val == 0
        val = 6
    return val - 1

fn set_player_x()
    U scr_x = TOP_SCREEN + U(player_x * 24)
    set_oam_x(0, scr_x)
    set_oam_x(4, scr_x + 8)
    set_oam_x(8, scr_x)
    set_oam_x(12, scr_x + 8)

fn set_player_y()
    U scr_y = LEFT_SCREEN + U(player_y * 24)
    set_oam_y(0, scr_y)
    set_oam_y(4, scr_y)
    set_oam_y(8, scr_y + 8)
    set_oam_y(12, scr_y + 8)

fn set_visible()
: +inline
    U i = U(player_z * 36) + U(player_y * 6) + player_x
    map[i] |= $80

fn queue_draw_floor()
: +inline
    action = ACT_DRAW_FLOOR
    to_redraw = 36

fn pads_level()
    U pressed = pads[0].pressed
    if pressed & BUTTON_UP
        //Debug: move between floors
        if pads[0].held & BUTTON_SELECT
            player_z = dec_wrap(player_z)
            queue_draw_floor()
        else
            player_y = dec_wrap(player_y)
            set_player_y()
            action = ACT_DRAW_CELL
    else if pressed & BUTTON_DOWN
        //Debug: move between floors
        if pads[0].held & BUTTON_SELECT
            player_z = inc_wrap(player_z)
            queue_draw_floor()
        else
            player_y = inc_wrap(player_y)
            set_player_y()
            action = ACT_DRAW_CELL
    if pressed & BUTTON_LEFT
        player_x = dec_wrap(player_x)
        set_player_x()
        action = ACT_DRAW_CELL
    else if pressed & BUTTON_RIGHT
        player_x = inc_wrap(player_x)
        set_player_x()
        action = ACT_DRAW_CELL
    //DEBUG: show/hide cells
    if pressed & BUTTON_A && pads[0].held & BUTTON_SELECT
        visible_debug = !visible_debug
        queue_draw_floor()

nmi main_nmi()
    redraw()
    ppu_upload_oam_poll_pads(0)
    ppu_reset_scroll(0, 0)
    {PPUCTRL}(%10001000)
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)

fn set_oam_pa(I.oam index, U p, U a)
: +inline
    oam{OAM_P + UU(index)} = p
    oam{OAM_A + UU(index)} = a

mode main() 
: nmi main_nmi
    {PPUCTRL}(0)
    {PPUMASK}(0)
    // Set the palette:
    palette = game_palette
    ppu_upload_palette()

    load_nametable(@level_bkg)
    generate_map()
    player_x = randb(6)
    player_y = randb(6)
    player_z = randb(6)
    show_current_cell()

    //Set the player sprite
    set_oam_pa(0, $02, 0)
    set_oam_pa(4, $03, 0)
    set_oam_pa(8, $12, 0)
    set_oam_pa(12, $13, 0)
    set_player_x()
    set_player_y()

    //Set sprites for room borders
    U spr = 16
    for U x = 16; x < 16 + 7 * 24; x += 24
        for U y = 16; y < 16 + 7 * 24; y += 24
            spr = push_oam(spr, x, y, $11, 3)
            hide_oam(spr)

    {PPUCTRL}(PPUCTRL_NMI_ON)

    while true
        update_pads()
        pads_level()
        nmi

chrrom
    file(fmt, "assets/layout.chr")
